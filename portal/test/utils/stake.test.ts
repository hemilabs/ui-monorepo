import { hemi, hemiSepolia } from 'hemi-viem'
import { stakeManagerAddresses } from 'hemi-viem-stake-actions'
import { stakedBalance, unstakeToken } from 'hemi-viem-stake-actions/actions'
import { HemiWalletClient } from 'hooks/useHemiClient'
import { EvmToken } from 'types/token'
import { canSubmit, stake, unstake } from 'utils/stake'
import { parseTokenUnits } from 'utils/token'
import { Hash, parseUnits, zeroAddress } from 'viem'
import { allowance, approve, balanceOf } from 'viem-erc20/actions'
import { describe, expect, it, vi } from 'vitest'

vi.mock('viem-erc20/actions', () => ({
  allowance: vi.fn(),
  approve: vi.fn(),
  balanceOf: vi.fn(),
}))

vi.mock('hemi-viem-stake-actions/actions', () => ({
  stakedBalance: vi.fn(),
  unstakeToken: vi.fn(),
}))

// Minimal t mock for tests, cast as any to bypass type checks
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const t = ((key: string) => key) as any

// @ts-expect-error Adding minimal properties needed
const token: EvmToken = {
  address: '0x0000000000000000000000000000000000000006',
  chainId: hemiSepolia.id,
  decimals: 18,
  symbol: 'fakeToken',
}

// fake transaction hash generated by an approval operation
const approvalTransactionHash =
  '0x0000000000000000000000000000000000000000000000000000000000000456' satisfies Hash
// fake transaction hash generated by a stake operation
const stakeTransactionHash =
  '0x0000000000000000000000000000000000000000000000000000000000000123' satisfies Hash
// fake transaction hash generated by an unstake operation
const unstakeTransactionHash =
  '0x0000000000000000000000000000000000000000000000000000000000000789' satisfies Hash

// @ts-expect-error only add the minimum values required
const hemiPublicClient: PublicClient = {
  chain: hemiSepolia,
  getBalance: vi.fn(),
  waitForTransactionReceipt: vi.fn(),
}
// @ts-expect-error only add the minimum values required
const hemiWalletClient: HemiWalletClient = {
  stakeERC20Token: vi.fn(),
  stakeETHToken: vi.fn(),
}

describe('utils/stake', function () {
  describe('canSubmit', function () {
    it('should return error if amount is empty', function () {
      const result = canSubmit({
        amountInput: '',
        balance: parseTokenUnits('100', token),
        operation: 'stake',
        t,
        token,
      })
      expect(result).toEqual({
        canSubmit: false,
        error: 'common.enter-an-amount',
        errorKey: 'enter-an-amount',
      })
    })

    it('should return error if balance is insufficient', function () {
      const result = canSubmit({
        amountInput: '100',
        balance: parseTokenUnits('10', token),
        operation: 'stake',
        t,
        token,
      })
      expect(result).toEqual({
        canSubmit: false,
        error: 'common.insufficient-balance',
        errorKey: 'insufficient-balance',
      })
    })

    it('should return canSubmit = true if all conditions are met', function () {
      const result = canSubmit({
        amountInput: '1',
        balance: parseTokenUnits('100', token),
        operation: 'stake',
        t,
        token,
      })
      expect(result).toEqual({
        canSubmit: true,
        error: undefined,
        errorKey: undefined,
      })
    })
  })

  describe('stake', function () {
    it('should throw error if chain ID does not match', async function () {
      const wrongChainClient = {
        ...hemiPublicClient,
        chain: hemi,
      }
      allowance.mockResolvedValue(BigInt(0))
      balanceOf.mockResolvedValue(parseTokenUnits('10', token))

      await expect(
        stake({
          amountInput: '1',
          forAccount: zeroAddress,
          hemiPublicClient: wrongChainClient,
          hemiWalletClient,
          t,
          token,
        }),
      ).rejects.toThrow('common.connect-to-network')
    })

    it('should throw error if the user has not enough balance', async function () {
      allowance.mockResolvedValue(BigInt(0))
      balanceOf.mockResolvedValue(BigInt(0))

      await expect(
        stake({
          amountInput: '1',
          forAccount: zeroAddress,
          hemiPublicClient,
          hemiWalletClient,
          t,
          token,
        }),
      ).rejects.toThrow('common.insufficient-balance')
    })

    it('should call stakeERC20Token if the token has enough allowance', async function () {
      // the user has enough balance
      allowance.mockResolvedValue(parseUnits('1', token.decimals))
      // the token has enough allowance
      balanceOf.mockResolvedValue(parseUnits('1', token.decimals))
      // fake transaction hash generated by staking
      hemiWalletClient.stakeERC20Token.mockResolvedValue(stakeTransactionHash)
      // fake waiting for receipt
      hemiPublicClient.waitForTransactionReceipt.mockResolvedValue({
        status: 'success',
      })

      const amountInput = '1'

      const onStake = vi.fn()
      const onStakeConfirmed = vi.fn()
      const onStakeFailed = vi.fn()
      const onStakeTokenApprovalFailed = vi.fn()
      const onStakeTokenApproved = vi.fn()
      const onTokenApprove = vi.fn()
      const onUserRejectedStake = vi.fn()
      const onUserRejectedTokenApproval = vi.fn()
      const onUserSignedStake = vi.fn()
      const onUserSignedTokenApproval = vi.fn()

      await stake({
        amountInput,
        forAccount: zeroAddress,
        hemiPublicClient,
        hemiWalletClient,
        onStake,
        onStakeConfirmed,
        onStakeFailed,
        onStakeTokenApprovalFailed,
        onStakeTokenApproved,
        onTokenApprove,
        onUserRejectedStake,
        onUserRejectedTokenApproval,
        onUserSignedStake,
        onUserSignedTokenApproval,
        t,
        token,
      })

      // assert event functions
      expect(onStake).toHaveBeenCalledOnce()
      expect(onStakeConfirmed).toHaveBeenCalledOnce()
      expect(onStakeFailed).not.toHaveBeenCalled()
      expect(onStakeTokenApprovalFailed).not.toHaveBeenCalled()
      expect(onStakeTokenApproved).not.toHaveBeenCalled()
      expect(onTokenApprove).not.toHaveBeenCalled()
      expect(onUserRejectedStake).not.toHaveBeenCalled()
      expect(onUserRejectedTokenApproval).not.toHaveBeenCalled()
      expect(onUserSignedStake).toHaveBeenCalledWith(stakeTransactionHash)
      expect(onUserSignedTokenApproval).not.toHaveBeenCalled()

      // assert event call
      expect(hemiWalletClient.stakeERC20Token).toHaveBeenCalledWith({
        amount: parseUnits(amountInput, token.decimals),
        forAccount: zeroAddress,
        tokenAddress: token.address,
      })
    })

    it('should first approve and then call stakeERC20Token if the token does not have enough allowance', async function () {
      // the user has enough balance
      balanceOf.mockResolvedValue(parseUnits('1', token.decimals))
      // the token does not have enough allowance
      allowance.mockResolvedValue(BigInt(0))
      // fake transaction hashes generation
      approve.mockResolvedValue(approvalTransactionHash)

      hemiWalletClient.stakeERC20Token.mockResolvedValue(stakeTransactionHash)
      // fake waiting for approval receipt
      hemiPublicClient.waitForTransactionReceipt
        .mockResolvedValueOnce({
          status: 'success',
        })
        // fake waiting for stake receipt
        .mockResolvedValueOnce({ status: 'success' })

      const amountInput = '1'

      const onStake = vi.fn()
      const onStakeConfirmed = vi.fn()
      const onStakeFailed = vi.fn()
      const onStakeTokenApprovalFailed = vi.fn()
      const onStakeTokenApproved = vi.fn()
      const onTokenApprove = vi.fn()
      const onUserRejectedStake = vi.fn()
      const onUserRejectedTokenApproval = vi.fn()
      const onUserSignedStake = vi.fn()
      const onUserSignedTokenApproval = vi.fn()

      await stake({
        amountInput,
        forAccount: zeroAddress,
        hemiPublicClient,
        hemiWalletClient,
        onStake,
        onStakeConfirmed,
        onStakeFailed,
        onStakeTokenApprovalFailed,
        onStakeTokenApproved,
        onTokenApprove,
        onUserRejectedStake,
        onUserRejectedTokenApproval,
        onUserSignedStake,
        onUserSignedTokenApproval,
        token,
      })

      // assert event functions
      expect(onStake).toHaveBeenCalledOnce()
      expect(onUserRejectedTokenApproval).not.toHaveBeenCalled()
      expect(onStakeTokenApprovalFailed).not.toHaveBeenCalled()
      expect(onUserSignedTokenApproval).toHaveBeenCalledWith(
        approvalTransactionHash,
      )
      expect(onStakeTokenApproved).toHaveBeenCalledOnce()
      expect(onTokenApprove).toHaveBeenCalledOnce()
      expect(onUserRejectedStake).not.toHaveBeenCalled()
      expect(onStakeFailed).not.toHaveBeenCalled()
      expect(onUserSignedStake).toHaveBeenCalledWith(stakeTransactionHash)
      expect(onStakeConfirmed).toHaveBeenCalledOnce()

      const amount = parseUnits(amountInput, token.decimals)

      expect(approve).toHaveBeenCalledWith(hemiWalletClient, {
        address: token.address,
        amount,
        spender: stakeManagerAddresses[token.chainId],
      })
      expect(hemiWalletClient.stakeERC20Token).toHaveBeenCalledWith({
        amount,
        forAccount: zeroAddress,
        tokenAddress: token.address,
      })
    })
  })

  describe('unstake', function () {
    it('should throw error if chain ID does not match', async function () {
      const wrongChainClient = {
        ...hemiPublicClient,
        chain: hemi,
        stakedBalance: vi.fn().mockResolvedValue(parseTokenUnits('10', token)),
      }

      await expect(
        unstake({
          amountInput: '1',
          forAccount: zeroAddress,
          hemiPublicClient: wrongChainClient,
          hemiWalletClient,
          t,
          token,
        }),
      ).rejects.toThrow('common.connect-to-network')
    })

    it('should throw error if the user has not enough staked balance', async function () {
      stakedBalance.mockResolvedValue(BigInt(0))

      await expect(
        unstake({
          amountInput: '1',
          forAccount: zeroAddress,
          hemiPublicClient,
          hemiWalletClient,
          t,
          token,
        }),
      ).rejects.toThrow('common.insufficient-balance')
    })

    it('should call unstakeToken if the user has enough staked balance', async function () {
      const amountInput = '1'
      const amount = parseUnits(amountInput, token.decimals)
      // the user has enough staked balance
      stakedBalance.mockResolvedValue(amount)
      // fake transaction hash generated by unstaking
      unstakeToken.mockResolvedValue(unstakeTransactionHash)
      // fake waiting for receipt
      hemiPublicClient.waitForTransactionReceipt.mockResolvedValue({
        status: 'success',
      })

      const onUnstake = vi.fn()
      const onUnstakeConfirmed = vi.fn()
      const onUnstakeFailed = vi.fn()
      const onUserRejectedUnstake = vi.fn()
      const onUserSignedUnstake = vi.fn()

      await unstake({
        amountInput,
        forAccount: zeroAddress,
        hemiPublicClient,
        hemiWalletClient,
        onUnstake,
        onUnstakeConfirmed,
        onUnstakeFailed,
        onUserRejectedUnstake,
        onUserSignedUnstake,
        t,
        token,
      })

      // assert event functions
      expect(onUnstake).toHaveBeenCalledOnce()
      expect(onUserRejectedUnstake).not.toHaveBeenCalled()
      expect(onUnstakeFailed).not.toHaveBeenCalled()
      expect(onUserSignedUnstake).toHaveBeenCalledWith(unstakeTransactionHash)
      expect(onUnstakeConfirmed).toHaveBeenCalledOnce()

      // assert event call
      expect(unstakeToken).toHaveBeenCalledWith(hemiWalletClient, {
        amount,
        forAccount: zeroAddress,
        tokenAddress: token.address,
      })
    })
  })
})
